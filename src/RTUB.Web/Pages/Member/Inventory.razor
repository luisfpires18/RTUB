@page "/inventory"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using RTUB.Application.Interfaces
@using RTUB.Core.Entities
@using RTUB.Core.Enums
@using RTUB.Core.Helpers
@using RTUB.Shared
@attribute [Authorize]
@inject IInstrumentService InstrumentService
@inject IImageStorageService ImageStorageService
@inject AuthenticationStateProvider AuthenticationStateProvider

<h1>Instrumentos</h1>
<p class="lead mb-4">Instrumentos da RTUB</p>

<!-- Add Button (Admin/Owner only) -->
<AuthorizeView Roles="Admin,Owner">
    <Authorized>
        <div class="mb-3">
            <button class="btn btn-success" @onclick="OpenCreateInstrumentModal" title="Novo Instrumento" disabled="@(loading || !categories.Any())">
                <i class="bi bi-plus-lg"></i>
            </button>
        </div>
    </Authorized>
</AuthorizeView>

@if (loading)
{
    <p>A carregar instrumentos...</p>
}
else if (!instruments.Any())
{
    <EmptyState Title="Nenhum instrumento registrado."
                    Icon="bi-music-note-beamed" />
}
else
{
    <!-- Stats - 2x2 CSS Grid Centered -->
    <div class="d-flex justify-content-center mb-4">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; max-width: 700px; width: 100%;">
            <div class="card">
                <div class="card-body text-center">
                    <h6 class="card-subtitle mb-2 text-muted">Total</h6>
                    <h3 class="card-title">@instruments.Count</h3>
                </div>
            </div>
            @{
                var statsArray = conditionStats.OrderBy(c => c.Key).ToList();
                for (int i = 0; i < Math.Min(3, statsArray.Count); i++)
                {
                    var stat = statsArray[i];
                    <div class="card">
                        <div class="card-body text-center">
                            <h6 class="card-subtitle mb-2 text-muted">@InstrumentConditionHelper.GetDisplayName(stat.Key)</h6>
                            <h3 class="card-title">@stat.Value</h3>
                        </div>
                    </div>
                }
            }
        </div>
    </div>

    <!-- Filters -->
    <div class="row mb-3">
        <div class="col-md-4">
            <FilterDropdown ShowIcon="false"
                          AllItemsLabel="Todos os tipos"
                          Items="@categories"
                          @bind-SelectedValue="filterCategory"
                          OnChange="ApplyFilters" />
        </div>
        <div class="col-md-4">
            <select class="form-select" @bind="filterCondition" @bind:after="ApplyFilters">
                <option value="">Todas as condições</option>
                @foreach (InstrumentCondition condition in Enum.GetValues(typeof(InstrumentCondition)))
                {
                    <option value="@condition">@InstrumentConditionHelper.GetDisplayName(condition)</option>
                }
            </select>
        </div>
    </div>

    <!-- Instruments Grid with InstrumentCircle Component -->
    <div class="row">
        @foreach (var instrument in paginatedInstruments)
        {
            <div class="col-md-4 col-lg-2 mb-4">
                <AuthorizeView Roles="Admin,Owner">
                    <Authorized>
                        <InstrumentCircle Instrument="@instrument" 
                                        ImageUrl="@GetImageUrl(instrument.ImageSrc)"
                                        ShowViewButton="true"
                                        ShowEditButton="true"
                                        ShowDeleteButton="true"
                                        OnView="@(() => OpenViewDetailsModal(instrument))"
                                        OnEdit="@(() => OpenEditInstrumentModal(instrument))"
                                        OnDelete="@(() => OpenDeleteInstrumentModal(instrument))" />
                    </Authorized>
                    <NotAuthorized>
                        <InstrumentCircle Instrument="@instrument" 
                                        ImageUrl="@GetImageUrl(instrument.ImageSrc)"
                                        ShowViewButton="true"
                                        OnView="@(() => OpenViewDetailsModal(instrument))" />
                    </NotAuthorized>
                </AuthorizeView>
            </div>
        }
    </div>

    <!-- Pagination Component -->
    <TablePagination CurrentPage="@currentPage"
                     PageSize="@itemsPerPage"
                     TotalItems="@filteredInstruments.Count"
                     ItemLabel="instrumentos"
                     PageSizeOptions="@(new[] { 6, 12, 18, 24, 30 })"
                     OnPageChanged="@HandlePageChanged"
                     OnPageSizeChanged="@HandlePageSizeChanged" />
}

<!-- Details Modal -->
<DetailsModal Show="@showViewDetailsModal" 
              ShowChanged="@((bool show) => showViewDetailsModal = show)"
              Title="Detalhes do Instrumento" 
              HeaderTitle="@(viewingInstrument?.Name ?? "")"
              ImageUrl="@(viewingInstrument != null && !string.IsNullOrEmpty(viewingInstrument.ImageUrl) ? GetImageUrl(viewingInstrument.ImageUrl) : null)"
              IconClass="@(viewingInstrument != null && string.IsNullOrEmpty(viewingInstrument.ImageUrl) ? "bi-music-note-beamed" : null)"
              UseRectangularImage="true"
              OnClose="CloseViewDetailsModal">
    <BadgesContent>
        @if (viewingInstrument != null)
        {
            <span class="badge bg-primary">@viewingInstrument.Category</span>
            <span class="badge @InstrumentConditionHelper.GetBadgeClass(viewingInstrument.Condition)">
                @InstrumentConditionHelper.GetDisplayName(viewingInstrument.Condition)
            </span>
        }
    </BadgesContent>
    <Sections>
        @if (viewingInstrument != null)
        {
            <!-- Instrument Information Section -->
            <InfoSection SectionTitle="Informações do Instrumento" 
                        IconClass="bi-info-circle-fill" 
                        CssClass="mb-4">
                <ProfileField Label="Tipo" Value="@viewingInstrument.Category" />
                <ProfileField Label="Marca" Value="@viewingInstrument.Brand" />
                <ProfileField Label="Número de Série" Value="@viewingInstrument.SerialNumber" />
                <ProfileField Label="Localização" Value="@viewingInstrument.Location" />
                <ProfileField Label="Condição" Value="@InstrumentConditionHelper.GetDisplayName(viewingInstrument.Condition)" />
                <ProfileField Label="Data Última Manutenção" 
                            Value="@(viewingInstrument.LastMaintenanceDate.HasValue ? viewingInstrument.LastMaintenanceDate.Value.ToString("dd/MM/yyyy") : null)" />
            </InfoSection>

            <!-- Maintenance Notes Section -->
            @if (!string.IsNullOrEmpty(viewingInstrument.MaintenanceNotes))
            {
                <InfoSection SectionTitle="Notas de Manutenção" 
                            IconClass="bi-wrench" 
                            CssClass="mb-3">
                    <p class="text-white-full mb-0">@viewingInstrument.MaintenanceNotes</p>
                </InfoSection>
            }
        }
    </Sections>
</DetailsModal>

<!-- CRUD Modals for Instruments -->
<CrudModalManager TEntity="Instrument"
                  ShowEditModal="@showInstrumentEditModal"
                  ShowEditModalChanged="@((value) => showInstrumentEditModal = value)"
                  IsCreateMode="@isInstrumentCreateMode"
                  EditingEntity="@editingInstrument"
                  CreateTitle="Novo Instrumento"
                  EditTitle="Editar Instrumento"
                  ModalSize="Modal.ModalSize.Large"
                  OnSave="SaveInstrument"
                  OnEditModalClosed="CloseInstrumentEditModal"
                  ShowDeleteModal="@showInstrumentDeleteModal"
                  ShowDeleteModalChanged="@((value) => showInstrumentDeleteModal = value)"
                  DeletingEntity="@deletingInstrument"
                  DeleteTitle="Confirmar Eliminação"
                  OnDelete="DeleteInstrument"
                  OnDeleteModalClosed="CloseInstrumentDeleteModal">
    <EditFormContent Context="instrument">
        <EditForm Model="instrument" OnValidSubmit="SaveInstrument">
            <DataAnnotationsValidator />
            <ErrorDisplay />

            <div class="row mb-3">
                <div class="col-md-6">
                    <label class="form-label">Nome *</label>
                    <InputText class="form-control" @bind-Value="instrument.Name" />
                </div>
                <div class="col-md-6">
                    <label class="form-label">Tipo *</label>
                    <InputSelect class="form-select" @bind-Value="instrument.Category">
                        <option value="">Selecione...</option>
                        @foreach (var category in categories)
                        {
                            <option value="@category">@category</option>
                        }
                    </InputSelect>
                </div>
            </div>

            <div class="row mb-3">
                <div class="col-md-6">
                    <label class="form-label">Marca</label>
                    <InputText class="form-control" @bind-Value="instrument.Brand" />
                </div>
                <div class="col-md-6">
                    <label class="form-label">Número de Série</label>
                    <InputText class="form-control" @bind-Value="instrument.SerialNumber" />
                </div>
            </div>

            <div class="row mb-3">
                <div class="col-md-6">
                    <label class="form-label">Condição *</label>
                    <InputSelect class="form-select" @bind-Value="instrument.Condition">
                        @foreach (InstrumentCondition condition in Enum.GetValues(typeof(InstrumentCondition)))
                        {
                            <option value="@condition">@InstrumentConditionHelper.GetDisplayName(condition)</option>
                        }
                    </InputSelect>
                </div>
                <div class="col-md-6">
                    <label class="form-label">Localização</label>
                    <InputText class="form-control" @bind-Value="instrument.Location" />
                </div>
            </div>

            <div class="row mb-3">
                <div class="col-md-6">
                    <label class="form-label">Data Última Manutenção</label>
                    <InputDate class="form-control" @bind-Value="instrument.LastMaintenanceDate" />
                </div>
                <div class="col-md-6">
                    <label class="form-label">Notas de Manutenção</label>
                    <InputTextArea class="form-control" @bind-Value="instrument.MaintenanceNotes" rows="3" />
                </div>
            </div>

            <div class="mb-3">
                <label class="form-label">Imagem</label>
                <InputFile class="form-control file-input-dark" OnChange="HandleInstrumentImageUpload" accept="image/*" />
                @if (!string.IsNullOrEmpty(editingInstrument?.ImageUrl) && uploadedInstrumentImagePath == null)
                {
                    <div class="mt-2">
                        <small class="text-muted">Imagem atual</small>
                        <br />
                        <img src="@GetImageUrl(editingInstrument.ImageUrl)" alt="Preview" class="img-thumbnail mt-1 slideshow-preview" />
                    </div>
                }
                @if (uploadedInstrumentImagePath != null)
                {
                    <div class="mt-2">
                        <small class="text-success">Nova imagem carregada com sucesso!</small>
                    </div>
                }
                
                <!-- Info about image cropping -->
                <div class="alert alert-info mt-3 identity-alert-info">
                    <i class="bi bi-info-circle-fill"></i>
                    <strong>Nota:</strong> Ao adicionar uma imagem, será apresentado um editor para recortar a imagem completa do instrumento 
                    e uma miniatura circular para exibição na lista. Ambos os recortes devem ser concluídos antes de guardar.
                </div>
            </div>

            <div class="d-flex justify-content-end gap-2">
                <button type="button" class="btn btn-secondary" @onclick="() => showInstrumentEditModal = false">Cancelar</button>
                <button type="submit" class="btn btn-success" disabled="@(!CanSaveInstrument())">Guardar</button>
            </div>
        </EditForm>
    </EditFormContent>
    <EditFormFooterContent>
        <!-- Footer is now inside the form -->
    </EditFormFooterContent>
    <DeleteConfirmationContent Context="instrument">
        <p>Tem a certeza que deseja eliminar o instrumento <strong>@instrument.Name</strong>?</p>
        <p class="text-muted small">Esta ação não pode ser revertida.</p>
    </DeleteConfirmationContent>
</CrudModalManager>

<!-- Image Cropper Component - Full Image -->
<ImageCropper @ref="imageCropper"
              ShowModal="showCropperModal"
              ShowModalChanged="OnCropperModalChanged"
              OnImageCropped="OnImageCropped"
              AspectRatio="0"
              AspectRatioHelp="Crop to capture the full instrument - this will be shown in the details view"
              ImageFormat="image/webp"
              ImageQuality="0.85" />

<!-- Image Cropper Component - Thumbnail -->
<ImageCropper @ref="thumbnailCropper"
              ShowModal="showThumbnailCropperModal"
              ShowModalChanged="OnThumbnailCropperModalChanged"
              OnImageCropped="OnThumbnailImageCropped"
              AspectRatio="1.0"
              AspectRatioHelp="Define what is shown in the circular thumbnail - crop to show the best part of the instrument"
              ImageFormat="image/webp"
              ImageQuality="0.85" />

@code {
    private bool loading = true;

    // Instruments
    private List<Instrument> instruments = new();
    private List<Instrument> filteredInstruments = new();
    private List<Instrument> paginatedInstruments = new();
    private List<string> categories = new();
    private Dictionary<InstrumentCondition, int> conditionStats = new();
    private string filterCategory = "";
    private string filterCondition = "";

    // Pagination
    private int currentPage = 1;
    private int itemsPerPage = 6;

    // Details Modal State
    private bool showViewDetailsModal = false;
    private Instrument? viewingInstrument;

    // CRUD Modal State
    private bool showInstrumentEditModal = false;
    private bool showInstrumentDeleteModal = false;
    private bool isInstrumentCreateMode = false;
    private Instrument? editingInstrument;
    private Instrument? deletingInstrument;

    // Image Cropper
    private bool showCropperModal = false;
    private ImageCropper? imageCropper;
    private IBrowserFile? selectedFile;
    private string? uploadedInstrumentImagePath;
    private int imageRefreshTrigger = 0;
    private byte[]? croppedInstrumentImageBytes;
    private string? croppedInstrumentImageFileName = "instrument-image.webp";
    
    // Thumbnail Cropper
    private bool showThumbnailCropperModal = false;
    private ImageCropper? thumbnailCropper;
    private byte[]? croppedThumbnailImageBytes;
    private string? croppedThumbnailImageFileName = "instrument-thumbnail.webp";

    protected override async Task OnInitializedAsync()
    {
        LoadCategoriesFromEnum();
        await LoadData();
    }

    private void LoadCategoriesFromEnum()
    {
        categories = Enum.GetValues<InstrumentType>()
            .Select(e => e.ToString())
            .ToList();
    }

    private async Task LoadData()
    {
        loading = true;

        var instrumentsList = await InstrumentService.GetAllAsync();
        instruments = instrumentsList.ToList();
        filteredInstruments = instruments;

        conditionStats = await InstrumentService.GetConditionStatsAsync();

        // Apply initial pagination
        ApplyPagination();

        loading = false;
    }

    private void ApplyFilters()
    {
        filteredInstruments = instruments;

        if (!string.IsNullOrEmpty(filterCategory))
        {
            filteredInstruments = filteredInstruments.Where(i => i.Category == filterCategory).ToList();
        }

        if (!string.IsNullOrEmpty(filterCondition) && Enum.TryParse<InstrumentCondition>(filterCondition, out var condition))
        {
            filteredInstruments = filteredInstruments.Where(i => i.Condition == condition).ToList();
        }

        // Reset to first page when filters change
        currentPage = 1;
        ApplyPagination();
    }

    private void ApplyPagination()
    {
        var skip = (currentPage - 1) * itemsPerPage;
        paginatedInstruments = filteredInstruments.Skip(skip).Take(itemsPerPage).ToList();
    }

    private Task HandlePageChanged(int newPage)
    {
        currentPage = newPage;
        ApplyPagination();
        return Task.CompletedTask;
    }

    private Task HandlePageSizeChanged(int newPageSize)
    {
        itemsPerPage = newPageSize;
        currentPage = 1; // Reset to first page when page size changes
        ApplyPagination();
        return Task.CompletedTask;
    }

    // Details Modal Methods
    private void OpenViewDetailsModal(Instrument instrument)
    {
        viewingInstrument = instrument;
        showViewDetailsModal = true;
    }

    private void CloseViewDetailsModal()
    {
        showViewDetailsModal = false;
        viewingInstrument = null;
    }

    // CRUD Modal Methods
    private void OpenCreateInstrumentModal()
    {
        if (!categories.Any())
        {
            StateHasChanged();
            return;
        }
        
        editingInstrument = Instrument.CreateEmpty();
        isInstrumentCreateMode = true;
        uploadedInstrumentImagePath = null;
        croppedInstrumentImageBytes = null;
        croppedThumbnailImageBytes = null;
        showInstrumentEditModal = true;
    }

    private void OpenEditInstrumentModal(Instrument instrument)
    {
        editingInstrument = instrument;
        isInstrumentCreateMode = false;
        uploadedInstrumentImagePath = null;
        croppedInstrumentImageBytes = null;
        croppedThumbnailImageBytes = null;
        showInstrumentEditModal = true;
    }

    private void OpenDeleteInstrumentModal(Instrument instrument)
    {
        deletingInstrument = instrument;
        showInstrumentDeleteModal = true;
    }

    private async Task SaveInstrument()
    {
        if (editingInstrument == null) return;

        try
        {
            if (isInstrumentCreateMode)
            {
                await InstrumentService.CreateAsync(editingInstrument);
                
                // If full image was cropped, upload it now with the correct ID
                if (croppedInstrumentImageBytes != null && croppedInstrumentImageBytes.Length > 0)
                {
                    using var stream = new MemoryStream(croppedInstrumentImageBytes);
                    var imageUrl = await ImageStorageService.UploadImageAsync(stream, croppedInstrumentImageFileName!, "image/webp", "instruments", editingInstrument.Id.ToString());
                    editingInstrument.ImageUrl = imageUrl;
                }
                
                // If thumbnail was cropped, upload it as well
                if (croppedThumbnailImageBytes != null && croppedThumbnailImageBytes.Length > 0)
                {
                    using var stream = new MemoryStream(croppedThumbnailImageBytes);
                    var thumbnailUrl = await ImageStorageService.UploadImageAsync(stream, croppedThumbnailImageFileName!, "image/webp", "instruments/thumbnails", editingInstrument.Id.ToString());
                    editingInstrument.ThumbnailUrl = thumbnailUrl;
                }
                
                if (croppedInstrumentImageBytes != null || croppedThumbnailImageBytes != null)
                {
                    await InstrumentService.UpdateAsync(editingInstrument);
                }
            }
            else
            {
                // Upload full image to R2 if one was cropped
                if (croppedInstrumentImageBytes != null && croppedInstrumentImageBytes.Length > 0)
                {
                    // Delete old image if it exists
                    if (!string.IsNullOrEmpty(editingInstrument.ImageUrl))
                    {
                        await ImageStorageService.DeleteImageAsync(editingInstrument.ImageUrl);
                    }
                    
                    using var stream = new MemoryStream(croppedInstrumentImageBytes);
                    var imageUrl = await ImageStorageService.UploadImageAsync(stream, croppedInstrumentImageFileName!, "image/webp", "instruments", editingInstrument.Id.ToString());
                    editingInstrument.ImageUrl = imageUrl;
                }
                
                // Upload thumbnail if one was cropped
                if (croppedThumbnailImageBytes != null && croppedThumbnailImageBytes.Length > 0)
                {
                    // Delete old thumbnail if it exists
                    if (!string.IsNullOrEmpty(editingInstrument.ThumbnailUrl))
                    {
                        await ImageStorageService.DeleteImageAsync(editingInstrument.ThumbnailUrl);
                    }
                    
                    using var stream = new MemoryStream(croppedThumbnailImageBytes);
                    var thumbnailUrl = await ImageStorageService.UploadImageAsync(stream, croppedThumbnailImageFileName!, "image/webp", "instruments/thumbnails", editingInstrument.Id.ToString());
                    editingInstrument.ThumbnailUrl = thumbnailUrl;
                }
                
                await InstrumentService.UpdateAsync(editingInstrument);
                
                // Invalidate server-side cache if image was updated
                if (!string.IsNullOrEmpty(editingInstrument.ImageUrl) && uploadedInstrumentImagePath != null)
                {
                    // Increment trigger to force browser to re-fetch the image
                    imageRefreshTrigger++;
                }
            }

            await LoadData();
            showInstrumentEditModal = false;
            uploadedInstrumentImagePath = null;
            croppedInstrumentImageBytes = null;
            croppedThumbnailImageBytes = null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving instrument: {ex.Message}");
        }
    }

    private async Task DeleteInstrument()
    {
        if (deletingInstrument == null) return;

        try
        {
            await InstrumentService.DeleteAsync(deletingInstrument.Id);
            await LoadData();
            showInstrumentDeleteModal = false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting instrument: {ex.Message}");
        }
    }

    private void CloseInstrumentEditModal()
    {
        showInstrumentEditModal = false;
        editingInstrument = null;
        uploadedInstrumentImagePath = null;
        croppedInstrumentImageBytes = null;
        croppedThumbnailImageBytes = null;
    }

    private void CloseInstrumentDeleteModal()
    {
        showInstrumentDeleteModal = false;
        deletingInstrument = null;
    }

    // Image Upload Methods
    private async Task HandleInstrumentImageUpload(InputFileChangeEventArgs e)
    {
        try
        {
            var imageFile = e.File;
            if (imageFile != null)
            {
                var maxFileSize = 10 * 1024 * 1024;
                if (imageFile.Size > maxFileSize)
                {
                    return;
                }

                selectedFile = imageFile;

                if (imageCropper != null)
                {
                    await imageCropper.LoadImageAsync(selectedFile);
                }
            }
        }
        catch (Exception)
        {
            // Handle error silently or show message
        }
    }

    private async void OnImageCropped(byte[] croppedImageData)
    {
        try
        {
            if (croppedImageData != null && croppedImageData.Length > 0)
            {
                if (editingInstrument != null)
                {
                    // Store the cropped full image bytes
                    croppedInstrumentImageBytes = croppedImageData;
                    uploadedInstrumentImagePath = "uploaded";
                    
                    // Now load the same image into the thumbnail cropper
                    if (thumbnailCropper != null && selectedFile != null)
                    {
                        await thumbnailCropper.LoadImageAsync(selectedFile);
                    }
                }
                
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnThumbnailImageCropped(byte[] croppedImageData)
    {
        try
        {
            if (croppedImageData != null && croppedImageData.Length > 0)
            {
                if (editingInstrument != null)
                {
                    // Store the cropped thumbnail bytes
                    croppedThumbnailImageBytes = croppedImageData;
                }
                
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnCropperModalChanged(bool isOpen)
    {
        showCropperModal = isOpen;
        StateHasChanged();
    }

    private void OnThumbnailCropperModalChanged(bool isOpen)
    {
        showThumbnailCropperModal = isOpen;
        StateHasChanged();
    }

    private bool CanSaveInstrument()
    {
        // If an image has been uploaded (selectedFile is not null), both crops must be completed
        // before allowing save to prevent bugs
        if (selectedFile != null)
        {
            // Both full image and thumbnail must be cropped
            return croppedInstrumentImageBytes != null && croppedThumbnailImageBytes != null;
        }
        
        // If no new image uploaded, can always save
        return true;
    }

    private string GetImageUrl(string imageSrc)
    {
        if (string.IsNullOrEmpty(imageSrc)) return string.Empty;
        
        // Add refresh trigger only when an image has been updated
        // This forces browser to re-fetch after edits while maintaining ETag caching
        if (imageRefreshTrigger > 0 && imageSrc.StartsWith("/api/images/"))
        {
            return $"{imageSrc}?r={imageRefreshTrigger}";
        }
        
        return imageSrc;
    }
}
