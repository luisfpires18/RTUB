@page "/images"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using RTUB.Application.Interfaces
@using RTUB.Application.Helpers
@using RTUB.Shared
@attribute [Authorize(Roles = "Admin")]
@inherits CrudTablePageBase<Slideshow>
@inject ISlideshowService SlideshowService
@inject IWebHostEnvironment Environment

<h1>Gestão de Apresentação</h1>
<p class="lead mb-4 text-light-theme">Gerir imagens de apresentação na página inicial.</p>

<div class="mb-3">
    <button class="btn btn-success mb-2" @onclick="OpenCreateModal" title="Adicionar Novo Slide">
        <i class="bi bi-plus-lg"></i>
    </button>
</div>

<!-- Search Box -->
<div class="row mb-3">
    <div class="col-md-6">
        <TableSearchBar 
            SearchTerm="@SearchTerm"
            OnSearchChanged="UpdateSearch"
            Placeholder="Pesquisar por título ou descrição..." />
    </div>
</div>

@if (AllItems == null)
{
    <p>A carregar slides...</p>
}
else if (!PaginatedItems.Any())
{
    <EmptyState Title="Nenhum slideshow encontrado"
                Message="Não foram encontrados slideshows que correspondam à sua pesquisa."
                Icon="bi-info-circle" />
}
else
{
    <!-- Slideshow Cards -->
    <div class="slideshow-list mb-4">
        @foreach (var slide in PaginatedItems)
        {
            <SlideshowCard Slide="@slide"
                          ImageUrl="@GetSlideshowImageUrl(slide.ImageSrc)"
                          ShowAdminControls="true"
                          OnClick="@((s) => { })"
                          OnEdit="@((s) => OpenEditModal(s))"
                          OnDelete="@((s) => OpenDeleteModal(s))" />
        }
    </div>

    <!-- Pagination -->
    <TablePagination CurrentPage="@PaginationHelper.CurrentPage"
                    PageSize="@PaginationHelper.PageSize"
                    TotalItems="@FilteredItems.Count"
                    ItemLabel="slides"
                    PageSizeOptions="@(new[] { 3, 6, 9, 12, 15 })"
                    OnPageChanged="ChangePage"
                    OnPageSizeChanged="ChangePageSize" />
}

<!-- CRUD Modals -->
<CrudModalManager TEntity="Slideshow"
                  ShowEditModal="@showEditModal"
                  ShowEditModalChanged="@((value) => showEditModal = value)"
                  IsCreateMode="@isCreateMode"
                  EditingEntity="@editingSlide"
                  CreateTitle="Criar Novo Slide"
                  EditTitle="Editar Slide"
                  OnSave="SaveSlide"
                  OnEditModalClosed="CloseEditModal"
                  ShowDeleteModal="@showDeleteModal"
                  ShowDeleteModalChanged="@((value) => showDeleteModal = value)"
                  DeletingEntity="@deletingSlide"
                  DeleteTitle="Confirmar Eliminação"
                  OnDelete="DeleteSlide"
                  OnDeleteModalClosed="() => deletingSlide = null">
    <EditFormContent Context="slide">
        <EditForm Model="slide" OnValidSubmit="SaveSlide" @ref="slideshowEditForm">
            <DataAnnotationsValidator />
            <ErrorDisplay />

            <div class="mb-3">
                <label class="form-label">Título</label>
                <InputText class="form-control" @bind-Value="slide!.Title" />
            </div>

            <div class="mb-3">
                <label class="form-label">Descrição</label>
                <InputTextArea class="form-control" rows="3" @bind-Value="slide!.Description" />
            </div>

            <div class="mb-3">
                <label class="form-label">Ordem</label>
                <InputNumber class="form-control" @bind-Value="slide!.Order" />
            </div>

            <div class="mb-3">
                <label class="form-label">Intervalo (ms)</label>
                <InputNumber class="form-control" @bind-Value="slide!.IntervalMs" />
            </div>

            <ImageUploadManager @ref="imageUploadManager"
                               Label="Imagem"
                               CurrentImageUrl="@(uploadedImagePath == null && !string.IsNullOrEmpty(slide!.ImageSrc) ? GetSlideshowImageUrl(slide.ImageSrc) : null)"
                               ShowCurrentImage="@(uploadedImagePath == null)"
                               PreviewCssClass="slideshow-preview"
                               OnFileSelected="HandleImageUpload" />

            <div class="mb-3 form-check">
                <InputCheckbox class="form-check-input" id="isActive" @bind-Value="slide!.IsActive" />
                <label class="form-check-label" for="isActive">Ativo</label>
            </div>

            <div class="d-flex justify-content-end gap-2">
                <button type="button" class="btn btn-secondary" @onclick="CloseEditModal">Cancelar</button>
                <button type="submit" class="btn btn-primary btn-primary-purple">@(isCreateMode ? "Adicionar" : "Guardar")</button>
            </div>
        </EditForm>
    </EditFormContent>
    <EditFormFooterContent>
        <!-- Footer is now inside the form -->
    </EditFormFooterContent>
    <DeleteConfirmationContent Context="slide">
        <p>Tem a certeza que quer eliminar o slide <strong>@slide?.Title</strong>?</p>
        <p class="text-muted">Esta ação não pode ser revertida.</p>
    </DeleteConfirmationContent>
</CrudModalManager>

<!-- Image Cropper Component -->
<ImageCropper @ref="imageCropper"
              ShowModal="showCropperModal"
              ShowModalChanged="OnCropperModalChanged"
              OnImageCropped="OnImageCropped"
              AspectRatio="0"
              AspectRatioHelp="As imagens de apresentação podem ter qualquer proporção - use corte livre para manter as proporções originais"
              ImageFormat="image/webp"
              ImageQuality="0.9" />

@code {
    private bool showEditModal = false;
    private bool showDeleteModal = false;
    private bool showCropperModal = false;
    private bool isCreateMode = false;
    private Slideshow? editingSlide;
    private Slideshow? deletingSlide;
    private string? uploadedImagePath;
    private ImageCropper? imageCropper;
    private IBrowserFile? selectedFile;
    private ImageUploadManager? imageUploadManager;
    private int imageRefreshTrigger = 0;
    private byte[]? croppedSlideshowImageBytes;
    private string? croppedSlideshowImageFileName = "slideshow-image.webp";
    private EditForm? slideshowEditForm;

    protected override async Task OnInitializedAsync()
    {
        SortHelper.SortColumn = nameof(Slideshow.Order);
        PaginationHelper.PageSize = 3; // Default page size for slideshow list
        await LoadItemsAsync();
        ApplyFiltersAndPagination();
    }

    protected override async Task LoadItemsAsync()
    {
        AllItems = (await SlideshowService.GetAllSlideshowsAsync()).ToList();
    }

    protected override Dictionary<string, Func<Slideshow, IComparable>> GetSortColumnSelectors()
    {
        return new Dictionary<string, Func<Slideshow, IComparable>>
        {
            [nameof(Slideshow.Title)] = s => s.Title ?? "",
            [nameof(Slideshow.Order)] = s => s.Order,
            [nameof(Slideshow.IntervalMs)] = s => s.IntervalMs,
            [nameof(Slideshow.IsActive)] = s => s.IsActive ? 1 : 0
        };
    }

    protected override List<Func<Slideshow, string>> GetSearchSelectors()
    {
        return new List<Func<Slideshow, string>>
        {
            s => s.Title ?? "",
            s => s.Description ?? ""
        };
    }

    private void OpenCreateModal()
    {
        isCreateMode = true;
        uploadedImagePath = null;
        croppedSlideshowImageBytes = null;
        editingSlide = new Slideshow
        {
            Title = string.Empty,
            Description = string.Empty,
            ImageUrl = string.Empty,
            Order = (AllItems?.Max(s => (int?)s.Order) ?? 0) + 1,
            IntervalMs = 5000,
            IsActive = true
        };
        showEditModal = true;
    }

    private void OpenEditModal(Slideshow slide)
    {
        isCreateMode = false;
        uploadedImagePath = null;
        croppedSlideshowImageBytes = null;
        editingSlide = new Slideshow
        {
            Id = slide.Id,
            Title = slide.Title,
            Description = slide.Description,
            ImageUrl = slide.ImageUrl,
            Order = slide.Order,
            IntervalMs = slide.IntervalMs,
            IsActive = slide.IsActive,
            CreatedAt = slide.CreatedAt
        };
        showEditModal = true;
    }

    private void CloseEditModal()
    {
        showEditModal = false;
        editingSlide = null;
        uploadedImagePath = null;
        imageUploadManager?.Reset();
    }

    private async Task HandleImageUpload(IBrowserFile file)
    {
        try
        {
            if (file != null)
            {
                selectedFile = file;

                if (imageCropper != null)
                {
                    await imageCropper.LoadImageAsync(selectedFile);
                }
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnImageCropped(byte[] croppedImageData)
    {
        try
        {
            if (editingSlide != null && croppedImageData != null && croppedImageData.Length > 0)
            {
                croppedSlideshowImageBytes = croppedImageData;
                uploadedImagePath = "uploaded";
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnCropperModalChanged(bool isOpen)
    {
        showCropperModal = isOpen;
        StateHasChanged();
    }

    private async Task SaveSlide()
    {
        if (editingSlide == null || slideshowEditForm?.EditContext == null) return;

        var editContext = slideshowEditForm.EditContext;
        var messageStore = new ValidationMessageStore(editContext);
        messageStore.Clear();

        if (isCreateMode)
        {
            // Validate that an image was uploaded for new slideshows
            if (croppedSlideshowImageBytes == null || croppedSlideshowImageBytes.Length == 0)
            {
                messageStore.Add(() => editingSlide.Title, "É obrigatório carregar uma imagem para o slideshow.");
                editContext.NotifyValidationStateChanged();
                return;
            }
            
            var newSlide = await SlideshowService.CreateSlideshowAsync(
                editingSlide.Title,
                editingSlide.Order,
                editingSlide.Description ?? string.Empty,
                editingSlide.IntervalMs
            );
            
            // Upload image to R2
            using var stream = new MemoryStream(croppedSlideshowImageBytes);
            await SlideshowService.SetSlideshowImageAsync(newSlide.Id, stream, croppedSlideshowImageFileName!, "image/webp");
            
            if (editingSlide.IsActive)
            {
                await SlideshowService.ActivateSlideshowAsync(newSlide.Id);
            }
        }
        else
        {
            await SlideshowService.UpdateSlideshowAsync(
                editingSlide.Id,
                editingSlide.Title,
                editingSlide.Description ?? string.Empty,
                editingSlide.Order,
                editingSlide.IntervalMs
            );

            // Upload new image to R2 if one was cropped
            if (croppedSlideshowImageBytes != null && croppedSlideshowImageBytes.Length > 0 && uploadedImagePath != null)
            {
                using var stream = new MemoryStream(croppedSlideshowImageBytes);
                await SlideshowService.SetSlideshowImageAsync(editingSlide.Id, stream, croppedSlideshowImageFileName!, "image/webp");
                imageRefreshTrigger++;
            }

            if (editingSlide.IsActive)
            {
                await SlideshowService.ActivateSlideshowAsync(editingSlide.Id);
            }
            else
            {
                await SlideshowService.DeactivateSlideshowAsync(editingSlide.Id);
            }
        }

        await RefreshDataAsync();
        CloseEditModal();
    }

    private void OpenDeleteModal(Slideshow slide)
    {
        deletingSlide = slide;
        showDeleteModal = true;
    }

    private async Task DeleteSlide()
    {
        if (deletingSlide == null) return;

        await SlideshowService.DeleteSlideshowAsync(deletingSlide.Id);
        await RefreshDataAsync();

        showDeleteModal = false;
        deletingSlide = null;
    }

    private string GetSlideshowImageUrl(string imageSrc)
    {
        if (string.IsNullOrEmpty(imageSrc)) return string.Empty;
        
        // Add refresh trigger only when an image has been updated
        // This forces browser to re-fetch after edits while maintaining ETag caching
        if (imageRefreshTrigger > 0 && imageSrc.StartsWith("/api/images/"))
        {
            return $"{imageSrc}?r={imageRefreshTrigger}";
        }
        
        return imageSrc;
    }
}

