@page "/admin/slideshow-management"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using RTUB.Application.Interfaces
@using RTUB.Application.Helpers
@using RTUB.Shared
@attribute [Authorize(Roles = "Admin")]
@inherits CrudTablePageBase<Slideshow>
@inject ISlideshowService SlideshowService
@inject IImageService ImageService
@inject IWebHostEnvironment Environment

<h1>Gestão de Apresentação</h1>
<p class="lead mb-4 text-light-theme">Gerir imagens de apresentação na página inicial.</p>

<div class="mb-3">
    <button class="btn btn-success mb-2" @onclick="OpenCreateModal" title="Adicionar Novo Slide">
        <i class="bi bi-plus-lg"></i>
    </button>
</div>

<!-- Search Box -->
<div class="row mb-3">
    <div class="col-md-6">
        <TableSearchBar 
            SearchTerm="@SearchTerm"
            OnSearchChanged="UpdateSearch"
            Placeholder="Pesquisar por título ou descrição..." />
    </div>
</div>

@if (AllItems == null)
{
    <p>A carregar slides...</p>
}
else if (!PaginatedItems.Any())
{
    <EmptyTableState 
        Message="Nenhum slideshow encontrado." 
        IconClass="bi-info-circle" />
}
else
{
    <div class="table-responsive">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Imagem</th>
                    <SortableTableHeader 
                        HeaderText="Título" 
                        SortColumn="@nameof(Slideshow.Title)" 
                        CurrentSortColumn="@SortHelper.SortColumn"
                        IsSortAscending="@SortHelper.SortAscending"
                        OnSortChanged="SortBy" />
                    <SortableTableHeader 
                        HeaderText="Ordem" 
                        SortColumn="@nameof(Slideshow.Order)" 
                        CurrentSortColumn="@SortHelper.SortColumn"
                        IsSortAscending="@SortHelper.SortAscending"
                        OnSortChanged="SortBy" />
                    <SortableTableHeader 
                        HeaderText="Intervalo (ms)" 
                        SortColumn="@nameof(Slideshow.IntervalMs)" 
                        CurrentSortColumn="@SortHelper.SortColumn"
                        IsSortAscending="@SortHelper.SortAscending"
                        OnSortChanged="SortBy" />
                    <SortableTableHeader 
                        HeaderText="Ativo" 
                        SortColumn="@nameof(Slideshow.IsActive)" 
                        CurrentSortColumn="@SortHelper.SortColumn"
                        IsSortAscending="@SortHelper.SortAscending"
                        OnSortChanged="SortBy" />
                    <th>Ações</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var slide in PaginatedItems)
                {
                    <tr>
                        <td>
                            @if (!string.IsNullOrEmpty(slide.ImageSrc))
                            {
                                <img src="@GetSlideshowImageUrl(slide.ImageSrc)" alt="@slide.Title" class="slideshow-thumbnail img-thumbnail" />
                            }
                        </td>
                        <td>@slide.Title</td>
                        <td>@slide.Order</td>
                        <td>@slide.IntervalMs</td>
                        <td>
                            <span class="badge @(slide.IsActive ? "bg-success" : "bg-secondary")">
                                @(slide.IsActive ? "Ativo" : "Inativo")
                            </span>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-light me-1" @onclick="() => OpenEditModal(slide)" title="Editar">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="btn btn-sm btn-danger" @onclick="() => OpenDeleteModal(slide)" title="Eliminar">
                                <i class="bi bi-trash"></i>
                            </button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <!-- Pagination -->
    <TablePagination 
        CurrentPage="@PaginationHelper.CurrentPage"
        PageSize="@PaginationHelper.PageSize"
        TotalItems="@FilteredItems.Count"
        ItemLabel="slides"
        OnPageChanged="ChangePage"
        OnPageSizeChanged="ChangePageSize" />
}

<!-- CRUD Modals -->
<CrudModalManager TEntity="Slideshow"
                  ShowEditModal="@showEditModal"
                  ShowEditModalChanged="@((value) => showEditModal = value)"
                  IsCreateMode="@isCreateMode"
                  EditingEntity="@editingSlide"
                  CreateTitle="Criar Novo Slide"
                  EditTitle="Editar Slide"
                  OnSave="SaveSlide"
                  OnEditModalClosed="CloseEditModal"
                  ShowDeleteModal="@showDeleteModal"
                  ShowDeleteModalChanged="@((value) => showDeleteModal = value)"
                  DeletingEntity="@deletingSlide"
                  DeleteTitle="Confirmar Eliminação"
                  OnDelete="DeleteSlide"
                  OnDeleteModalClosed="() => deletingSlide = null">
    <EditFormContent Context="slide">
        <EditForm Model="slide" OnValidSubmit="SaveSlide">
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" />

            <div class="mb-3">
                <label class="form-label">Título</label>
                <InputText class="form-control" @bind-Value="slide!.Title" />
            </div>

            <div class="mb-3">
                <label class="form-label">Descrição</label>
                <InputTextArea class="form-control" rows="3" @bind-Value="slide!.Description" />
            </div>

            <div class="mb-3">
                <label class="form-label">Ordem</label>
                <InputNumber class="form-control" @bind-Value="slide!.Order" />
            </div>

            <div class="mb-3">
                <label class="form-label">Intervalo (ms)</label>
                <InputNumber class="form-control" @bind-Value="slide!.IntervalMs" />
            </div>

            <ImageUploadManager @ref="imageUploadManager"
                               Label="Imagem"
                               CurrentImageUrl="@(uploadedImagePath == null && !string.IsNullOrEmpty(slide!.ImageSrc) ? GetSlideshowImageUrl(slide.ImageSrc) : null)"
                               ShowCurrentImage="@(uploadedImagePath == null)"
                               PreviewCssClass="slideshow-preview"
                               OnFileSelected="HandleImageUpload" />

            <div class="mb-3 form-check">
                <InputCheckbox class="form-check-input" id="isActive" @bind-Value="slide!.IsActive" />
                <label class="form-check-label" for="isActive">Ativo</label>
            </div>

            <div class="d-flex justify-content-end gap-2">
                <button type="button" class="btn btn-secondary" @onclick="CloseEditModal">Cancelar</button>
                <button type="submit" class="btn btn-primary btn-primary-purple">@(isCreateMode ? "Adicionar" : "Guardar")</button>
            </div>
        </EditForm>
    </EditFormContent>
    <EditFormFooterContent>
        <!-- Footer is now inside the form -->
    </EditFormFooterContent>
    <DeleteConfirmationContent Context="slide">
        <p>Tem a certeza que quer eliminar o slide <strong>@slide?.Title</strong>?</p>
        <p class="text-muted">Esta ação não pode ser revertida.</p>
    </DeleteConfirmationContent>
</CrudModalManager>

<!-- Image Cropper Component -->
<ImageCropper @ref="imageCropper"
              ShowModal="showCropperModal"
              ShowModalChanged="OnCropperModalChanged"
              OnImageCropped="OnImageCropped"
              AspectRatio="0"
              AspectRatioHelp="As imagens de apresentação podem ter qualquer proporção - use corte livre para manter as proporções originais"
              ImageFormat="image/jpeg"
              ImageQuality="0.9" />

@code {
    private bool showEditModal = false;
    private bool showDeleteModal = false;
    private bool showCropperModal = false;
    private bool isCreateMode = false;
    private Slideshow? editingSlide;
    private Slideshow? deletingSlide;
    private string? uploadedImagePath;
    private ImageCropper? imageCropper;
    private IBrowserFile? selectedFile;
    private ImageUploadManager? imageUploadManager;
    private int imageRefreshTrigger = 0;

    protected override async Task OnInitializedAsync()
    {
        SortHelper.SortColumn = nameof(Slideshow.Order);
        await LoadItemsAsync();
        ApplyFiltersAndPagination();
    }

    protected override async Task LoadItemsAsync()
    {
        AllItems = (await SlideshowService.GetAllSlideshowsAsync()).ToList();
    }

    protected override Dictionary<string, Func<Slideshow, IComparable>> GetSortColumnSelectors()
    {
        return new Dictionary<string, Func<Slideshow, IComparable>>
        {
            [nameof(Slideshow.Title)] = s => s.Title ?? "",
            [nameof(Slideshow.Order)] = s => s.Order,
            [nameof(Slideshow.IntervalMs)] = s => s.IntervalMs,
            [nameof(Slideshow.IsActive)] = s => s.IsActive ? 1 : 0
        };
    }

    protected override List<Func<Slideshow, string>> GetSearchSelectors()
    {
        return new List<Func<Slideshow, string>>
        {
            s => s.Title ?? "",
            s => s.Description ?? ""
        };
    }

    private void OpenCreateModal()
    {
        isCreateMode = true;
        uploadedImagePath = null;
        editingSlide = new Slideshow
        {
            Title = string.Empty,
            Description = string.Empty,
            ImageUrl = string.Empty,
            Order = (AllItems?.Max(s => (int?)s.Order) ?? 0) + 1,
            IntervalMs = 5000,
            IsActive = true
        };
        showEditModal = true;
    }

    private void OpenEditModal(Slideshow slide)
    {
        isCreateMode = false;
        uploadedImagePath = null;
        editingSlide = new Slideshow
        {
            Id = slide.Id,
            Title = slide.Title,
            Description = slide.Description,
            ImageUrl = slide.ImageUrl,
            ImageData = slide.ImageData,
            ImageContentType = slide.ImageContentType,
            Order = slide.Order,
            IntervalMs = slide.IntervalMs,
            IsActive = slide.IsActive,
            CreatedAt = slide.CreatedAt
        };
        showEditModal = true;
    }

    private void CloseEditModal()
    {
        showEditModal = false;
        editingSlide = null;
        uploadedImagePath = null;
        imageUploadManager?.Reset();
    }

    private async Task HandleImageUpload(IBrowserFile file)
    {
        try
        {
            if (file != null)
            {
                selectedFile = file;

                if (imageCropper != null)
                {
                    await imageCropper.LoadImageAsync(selectedFile);
                }
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnImageCropped(byte[] croppedImageData)
    {
        try
        {
            if (editingSlide != null && croppedImageData != null && croppedImageData.Length > 0)
            {
                editingSlide.ImageData = croppedImageData;
                editingSlide.ImageContentType = "image/jpeg";
                uploadedImagePath = "uploaded";
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error
        }
    }

    private void OnCropperModalChanged(bool isOpen)
    {
        showCropperModal = isOpen;
        StateHasChanged();
    }

    private async Task SaveSlide()
    {
        if (editingSlide == null) return;

        if (isCreateMode)
        {
            var newSlide = await SlideshowService.CreateSlideshowAsync(
                editingSlide.Title,
                editingSlide.Order,
                editingSlide.Description ?? string.Empty,
                editingSlide.IntervalMs
            );
            
            if (editingSlide.ImageData != null)
            {
                await SlideshowService.SetSlideshowImageAsync(
                    newSlide.Id,
                    editingSlide.ImageData,
                    editingSlide.ImageContentType
                );
            }
            
            if (editingSlide.IsActive)
            {
                await SlideshowService.ActivateSlideshowAsync(newSlide.Id);
            }
        }
        else
        {
            await SlideshowService.UpdateSlideshowAsync(
                editingSlide.Id,
                editingSlide.Title,
                editingSlide.Description ?? string.Empty,
                editingSlide.Order,
                editingSlide.IntervalMs
            );

            if (editingSlide.ImageData != null)
            {
                await SlideshowService.SetSlideshowImageAsync(
                    editingSlide.Id,
                    editingSlide.ImageData,
                    editingSlide.ImageContentType
                );
                
                // Invalidate server-side cache to ensure new image is served
                ImageService.InvalidateSlideshowImageCache(editingSlide.Id);
                
                // Increment trigger to force browser to re-fetch the image
                imageRefreshTrigger++;
            }

            if (editingSlide.IsActive)
            {
                await SlideshowService.ActivateSlideshowAsync(editingSlide.Id);
            }
            else
            {
                await SlideshowService.DeactivateSlideshowAsync(editingSlide.Id);
            }
        }

        await RefreshDataAsync();
        CloseEditModal();
    }

    private void OpenDeleteModal(Slideshow slide)
    {
        deletingSlide = slide;
        showDeleteModal = true;
    }

    private async Task DeleteSlide()
    {
        if (deletingSlide == null) return;

        await SlideshowService.DeleteSlideshowAsync(deletingSlide.Id);
        await RefreshDataAsync();

        showDeleteModal = false;
        deletingSlide = null;
    }

    private string GetSlideshowImageUrl(string imageSrc)
    {
        if (string.IsNullOrEmpty(imageSrc)) return string.Empty;
        
        // Add refresh trigger only when an image has been updated
        // This forces browser to re-fetch after edits while maintaining ETag caching
        if (imageRefreshTrigger > 0 && imageSrc.StartsWith("/api/images/"))
        {
            return $"{imageSrc}?r={imageRefreshTrigger}";
        }
        
        return imageSrc;
    }
}

